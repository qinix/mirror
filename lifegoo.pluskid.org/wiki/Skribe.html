<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <title>Skribe</title>
    <meta name="generator" content="muse.el">
    <meta http-equiv="Content-Type"
          content="text/html; charset=utf-8">
    <LINK REL=StyleSheet HREF="css/style.css" TYPE="text/css">

    <script src="http://www.google-analytics.com/urchin.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      _uacct = "UA-2502495-1";
      urchinTracker();
    </script>

  </head>
  <body>
    <a id="top"></a>
    <h1>Skribe</h1>
<div id="wrap">
<div id="navmenu">
  <h2>Favourite</h2>
  <ul>
    <li><a href="index.html">Home</a></li>
    <li><a href="Emacs.html">Emacs</a></li>
    <li><a href="CommonLisp.html">Common Lisp</a></li>
  </ul>

  <h2>Unix</h2>
  <ul>
    <li><a href="Linux.html">Linux</a></li>
    <li><a href="Debian.html">Debian</a></li>
  </ul>

  <h2>Software</h2>
  <ul>
    <li><a href="Emacs.html">Emacs</a></li>
    <li><a href="Sawfish.html">Sawfish</a></li>
    <li><a href="Screen.html">Screen</a></li>
  </ul>

  <h2>Programming</h2>
  <ul>
    <li><a href="CAndCPlusPlus.html">C/C++</a></li>
    <li><a href="CommonLisp.html">Common Lisp</a></li>
    <li><a href="Scheme.html">Scheme</a></li>
    <li><a href="Python.html">Python</a></li>
  </ul>

</div>

<div id="content">
<!-- end header -->

<!--contents goes here--><div class="contents"><h2>Contents</h2>
<dl>
<dt>
<a href="#sec1">简介</a>
</dt>
<dt>
<a href="#sec2">获取</a>
</dt>
<dt>
<a href="#sec3">一个例子</a>
</dt>
</dl>
</div>


    <!-- Page published by Emacs Muse begins here -->
<h2><a name="sec1" id="sec1"></a>
简介</h2>

<p class="first">Skribe 是一个基于 Scheme 的文档处理系统。它主要有两个优点：</p>

<ol>
<li>Skribe 的语法和 HTML 很像，所以学习使用 Skribe 非常容易。</li>
<li>Skribe 并不是像 HTML 那样的标记语言，而是真正的程序设计语言，因此
可以轻而易举地使用各种复杂机制，比如动态生成文档的内容等。</li>
</ol>

<p>另外，由 Skribe 写成的文档可以很轻松地导出为 HTML 或者是 TeX 等格式。
Skribe 非常适合于写技术报告、API 文档等类型的文档。</p>


<h2><a name="sec2" id="sec2"></a>
获取</h2>

<p class="first">在它的<a href="http://www-sop.inria.fr/mimosa/fp/Skribe/">主页</a>上可以下载到最新版本的 Skribe 。Skribe 可以用 Bigloo 或者
STklos 来编译。或者，如果你使用 <a href="Debian.html">Debian</a> 系统，可以直接使用 apt-get 进行
安装：</p>

<pre class="example">
apt-get install skribe skribe-doc skribe-el skribe-example
</pre>

<p>装好之后就拥有了 skribe 系统以及它的文档和例子了。并且，还有一个用于
<a href="Emacs.html">Emacs</a> 的方便的编辑 Skribe 文档的 mode 。</p>


<h2><a name="sec3" id="sec3"></a>
一个例子</h2>

<p class="first">Skribe 的强大之处在于它能利用 <a href="Scheme.html">Scheme</a> 的强大之处。这几天在看 SICP 正好
看到那个八皇后的问题。可惜得出的结果是一个表的形式，不是很直观，于是我
就决定用 Skribe 生成一个表格来显示结果。</p>

<p>这里是 N 皇后问题的求解代码，我把它放在 <code>nqueen.skr</code> 里面：</p>

<div class="emacs-outer"><div class="emacs-title-right">
<div class="emacs-title-left">
<div class="emacs-cont-left">
<div class="emacs-cont-right">
<div class="emacs-footer-right">
<div class="emacs-footer-left"><pre class="src" style="background-color:#1f1f1f;color:#00ff00;"><style type="text/css"><!--       .comment {
        /* font-lock-comment-face */
        color: #ff7f24;
      }
      .comment-delimiter {
        /* font-lock-comment-delimiter-face */
        color: #ff7f24;
      }
      .function-name {
        /* font-lock-function-name-face */
        color: #87cefa;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
    --></style>(<span class="keyword">define</span> (<span class="function-name">enumerate-interval</span> from to)
  (<span class="keyword">define</span> (<span class="function-name">iter</span> result j)
    (<span class="keyword">if</span> (&lt; j from)
        result
        (iter (cons j result) (- j 1))))
  (iter '() to))
<span class="comment-delimiter">;;;; </span><span class="comment">skribe already defined `filter'
</span><span class="comment-delimiter">;; </span><span class="comment">(define (filter predicate sequence)
</span><span class="comment-delimiter">;;   </span><span class="comment">(cond ((null? sequence) '())
</span><span class="comment-delimiter">;;         </span><span class="comment">((predicate (car sequence))
</span><span class="comment-delimiter">;;          </span><span class="comment">(cons (car sequence)
</span><span class="comment-delimiter">;;                </span><span class="comment">(filter predicate (cdr sequence))))
</span><span class="comment-delimiter">;;         </span><span class="comment">(else (filter predicate (cdr sequence)))))
</span>(<span class="keyword">define</span> (<span class="function-name">flatmap</span> proc seq)
  (accumulate append '() (<span class="keyword">map</span> proc seq)))
(<span class="keyword">define</span> (<span class="function-name">accumulate</span> op initial sequence)
  (<span class="keyword">if</span> (null? sequence)
      initial
      (op (car sequence)
          (accumulate op initial (cdr sequence)))))

(<span class="keyword">define</span> (<span class="function-name">queens</span> board-size)
  (<span class="keyword">define</span> (<span class="function-name">queen-cols</span> k)
    (<span class="keyword">if</span> (= k 0)
        (list empty-board)
        (filter
         (<span class="keyword">lambda</span> (positions) (safe? k positions))
         (flatmap
          (<span class="keyword">lambda</span> (rest-of-queens)
            (<span class="keyword">map</span> (<span class="keyword">lambda</span> (new-row)
                   (adjoin-position new-row k rest-of-queens))
                 (enumerate-interval 1 board-size)))
          (queen-cols (- k 1))))))
  (queen-cols board-size))

(<span class="keyword">define</span> <span class="function-name">empty-board</span> '())

(<span class="keyword">define</span> (<span class="function-name">adjoin-position</span> new-row k rest-of-queens)
  (cons new-row rest-of-queens))

(<span class="keyword">define</span> (<span class="function-name">safe?</span> k positions)
  (<span class="keyword">let</span> ((new-row (car positions))
        (rest-of-queens (cdr positions)))
    (<span class="keyword">define</span> (<span class="function-name">iter</span> i positions)
      (<span class="keyword">cond</span> ((null? positions) #t)
            ((<span class="keyword">or</span> (= (car positions) new-row)
                 (= (+ (car positions) i) (+ new-row k))
                 (= (- (car positions) i) (- new-row k)))
             #f)
            (<span class="keyword">else</span> (iter (- i 1) (cdr positions)))))
    (iter (- k 1) rest-of-queens)))
</pre></div></div></div></div></div></div></div>

<p>然后，是生成表格的文档，我放在 <code>nqueen.skb</code> 里面：</p>

<div class="emacs-outer"><div class="emacs-title-right">
<div class="emacs-title-left">
<div class="emacs-cont-left">
<div class="emacs-cont-right">
<div class="emacs-footer-right">
<div class="emacs-footer-left"><pre class="src" style="background-color:#1f1f1f;color:#00ff00;"><style type="text/css"><!--       .builtin {
        /* font-lock-builtin-face */
        color: #b0c4de;
      }
      .keyword {
        /* font-lock-keyword-face */
        color: #00ffff;
      }
      .string {
        /* font-lock-string-face */
        color: #ffa07a;
      }
    --></style>(include <span class="string">"nqueen.skr"</span>)
(document <span class="builtin">:title</span> [N Queen Problem]
   (<span class="keyword">map</span> (<span class="keyword">lambda</span> (n)
           (section <span class="builtin">:title</span> [,(color <span class="builtin">:fg</span> <span class="string">"red"</span> n)-Queen Solution][
,(<span class="keyword">map</span> (<span class="keyword">lambda</span> (layout)
        (center (p (table <span class="builtin">:border</span> 2 <span class="builtin">:frame</span> <span class="string">"box"</span> <span class="builtin">:rules</span> <span class="string">"all"</span>
                      (<span class="keyword">map</span> (<span class="keyword">lambda</span> (queen-col)
                             (tr <span class="builtin">:bg</span> <span class="string">"yellow"</span>
                                 (<span class="keyword">map</span> (<span class="keyword">lambda</span> (col)
                                        (<span class="keyword">if</span> (= queen-col col)
                                            (td  (image <span class="builtin">:file</span> <span class="string">"queen.gif"</span>))
                                            (td <span class="string">""</span>)))
                                      (enumerate-interval 1 n))))
                            layout)))))
       (queens n))]))
       (enumerate-interval 1 8)))
</pre></div></div></div></div></div></div></div>

<p>之后我将它转换为 HTML 文档：</p>

<pre class="example">
skribe nqueen.skb -o nqueen.html
</pre>

<p>就是<a href="attachment/nqueen.html">这个</a>页面。很短的代码，生成了很大的一个文档，包含了， <code>1-8</code> 皇后问题
的解的直观显示。事实上，我只需要改动一个数字，就可以生成棋盘更大的情况
的时候的解。</p>


<!-- Page published by Emacs Muse ends here -->
  </div>
  </div>
  </body>
</html>
